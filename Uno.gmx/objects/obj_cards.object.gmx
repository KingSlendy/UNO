<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_cards</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 0;
outlineSpeed = 1 / 2;
outlineIndex = 0;
status = stack_normal;
holding = false;
highlighted = false;
minusX = 0;
minusY = 0;
cardID = -1;
totalCards = 0;
endAnimation = false;
penaltyCards = false;
choseColor = false;
scr_setCardType();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (status != stack_grab) exit;

for (var i = 0; i &lt; global.numberPlayers; i++) {
    if (targets[i]) {
        grabCards[i] = true;
        cardTimer[i] = 8;
    
        if (i == global.playerID) {
            totalCards = instance_number(obj_cards) - 2;
            buffer_seek(global.buffer, buffer_seek_start, 0);
            buffer_write(global.buffer, buffer_u8, packets.playerGrabCardsUpdate);
            buffer_write(global.buffer, buffer_u8, global.playerID);
            buffer_write(global.buffer, buffer_u8, newCards[global.playerID]);
            network_send_packet(global.socket, global.buffer, buffer_tell(global.buffer));
        }
    
        backAngle[i] = irandom_range(-10, 10);
        targets[i] = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (status != stack_grab) exit;

for (var i = 0; i &lt; global.numberPlayers; i++) {
    if (execute[i]) {
        if (i == global.playerID) {
            if (ds_list_size(global.cardList) &lt; 99) {
                with (instance_create(x, y, obj_cards)) event_user(1);
                
                scr_updateCards();
            }
            
            if (endAnimation) event_user(0);
        } else {
            with (obj_networkPlayer) {
                if (networkPlayerID == i) {
                    var setList = other.playerList[i];
                    
                    if (setList != noone) {
                        ds_list_clear(networkPlayerCards);
                    
                        for (var j = 0; j &lt; array_length_1d(setList); j++) {
                            ds_list_add(networkPlayerCards, setList[j]);
                        }
                    } else {
                        ds_list_insert(networkPlayerCards, 0, 0);
                    }
                }
            }
        }
        
        execute[i] = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (status == stack_grab) {
    for (var i = 0; i &lt; global.numberPlayers; i++) {
        if (cardCount[i] &gt;= newCards[i]) {
            cardCount[i] = 0;
            grabCards[i] = false;
            
            continue;
        }
    
        if (grabCards[i] &amp;&amp; cardTimer[i]++ &gt;= 8) {
            var newX = global.cardX[i];
            var newY = global.cardY[i];
            var animSpeed = 1;
        
            if (i == global.playerID) {
                var cardDistance = 44;
                newX = clamp(400 - (cardDistance * totalCards) / 2 - (cardDistance * cardCount[i]) / 2, 76, 724);
                
                if (totalCards + cardCount[i] == 0) newX = 400;
                
                animSpeed = point_distance(x, y, newX, newY) / point_distance(x, y, 400, newY);
            }
            
            cardCount[i]++;
            scr_playAnimation(animation_grab, x, y, newX, newY, 12 * animSpeed, 1, 0, i, cardCount[i] &gt;= newCards[i]); 
            cardTimer[i] = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (status != stack_normal || !holding) exit;

x = (mouse_x - minusX) + sprite_xoffset;
y = (mouse_y - minusY) + sprite_yoffset;
outlineIndex += outlineSpeed;
outlineIndex %= sprite_get_number(spr_cardsOutline);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (status != stack_normal || !holding) exit;

holding = false;
depth = -cardID;

if (global.playerTurn == global.playerID &amp;&amp; !global.playingAnimation &amp;&amp; !global.choosingColor &amp;&amp; !global.gameFinished) {
    if (place_meeting(x, y, obj_cards)) {
        with (instance_place(x, y, obj_cards)) {
            if (status == stack_answer) {
                if (scr_canAnswer(other.image_index)) {
                    image_index = other.image_index;
                    
                    if (array_contains(global.cardTypes[card_mystery], image_index)) {
                        image_index = array_pick(global.cardTypes[card_special]);
                        
                        if (irandom(4) == 0)
                            image_index = array_pick(global.cardTypes[global.cardColor]);
                    }
                    
                    if (array_contains(global.cardTypes[card_black], image_index)) {
                        var blackCard = image_index - 65;
                    
                        switch (blackCard) {
                            case 0: case 5:
                                instance_create(400, 304, obj_chooseColors);
                                
                                obj_gameController.alarm[0] = 0;
                                global.choosingColor = true;
                                break;
                                
                            case 1: case 2: case 3: case 4: global.cardColor = blackCard + 1; break;
                            case 6: case 7: case 8: case 9: global.cardColor = blackCard - 4; break;
                        }
                    } else {
                        global.cardColor = scr_cardMod(image_index, 4) + 1;
                    }
                    
                    scr_playAnimation(animation_answer, x, y, image_index);
                    
                    with (other) instance_destroy();
                    
                    global.answering = true;
                    event_user(0);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!global.gameInitial &amp;&amp; !global.gameStarted || global.gameFinished) exit;

if ((status == stack_grab || global.gameInitial) &amp;&amp; (!global.drew || global.gameMode == mode_traditional) &amp;&amp; global.sentNewCards == 0 &amp;&amp; !global.choosingColor &amp;&amp; !global.playingAnimation) {
    if (!global.gameInitial &amp;&amp; array_all(targets, false) &amp;&amp; global.playerTurn == global.playerID &amp;&amp; ds_list_size(global.cardList) &lt; 99) {
        if (global.gameMode == mode_traditional) {
            for (var i = 0; i &lt; ds_list_size(global.cardList); i++) {
                if (scr_canAnswer(ds_list_find_value(global.cardList, i))) {
                    exit;
                }
            }
        }
    
        targets[global.playerID] = true;
        newCards[global.playerID] = 1;
        global.drawing = true;
    }
    
    exit;
}

var holdingCard = false;

with (obj_cards) {
    if (status == stack_normal) {
        if (holding) holdingCard = true;
    }
}

if (status == stack_answer || holding || holdingCard || global.choosingColor) exit;

minusX = abs(mouse_x - (x - sprite_xoffset));
minusY = abs(mouse_y - (y - sprite_yoffset));
holding = true;
depth = -100;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.onlyQuestion) {
    image_index = 75;
    
    exit;
}

scr_shuffleCard();

if (in_range(global.specialsFrecuency, 1, 3)) {
    repeat (global.specialsFrequency - 1) {
        if (array_contains(global.cardTypes[card_special], image_index)) {
            scr_shuffleCard();
        }
    }
} else if (global.specialsFrecuency == 0) {
    while (!array_contains(global.cardTypes[card_special], image_index)) {
        scr_shuffleCard();
    }
} else {
    while (array_contains(global.cardTypes[card_special], image_index)) {
        scr_shuffleCard();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_updateCards();
var cardDrawn = 0;

with (obj_cards) {
    if (status == stack_normal &amp;&amp; cardID == 0) {
        cardDrawn = image_index;
    }
}

if (global.choosingColor) exit;

if (global.playerTurn == global.playerID || (global.gameInitial &amp;&amp; global.playerID == 0)) {
    if (!global.drawing &amp;&amp; (global.gameMode != mode_traditional || global.answering)) global.drew = false;
    if (global.timeLeft != 0 &amp;&amp; global.drawing &amp;&amp; (scr_canAnswer(cardDrawn) || global.gameMode == mode_traditional)) global.drew = true;
    
    var cardStack = 0;
    var sendCards = 0;
    var sendAll = false;
    var usedBoomerang = false;
    penaltyCards = false;
    
    with (obj_cards) {
        if (status == stack_answer) {
            cardStack = image_index;
        }
    }

    if (global.sentNewCards &gt; 0 &amp;&amp; (!global.answering || (!array_contains(global.cardTypes[card_add2], cardStack) &amp;&amp; !array_contains(global.cardTypes[card_boomerang], cardStack)))) {
        with (obj_cards) {
            if (status == stack_grab) {
                targets[global.playerID] = true;
                newCards[global.playerID] = global.sentNewCards;
                global.sentNewCards = 0;
            }
        }
        
        penaltyCards = true;
    }
    
    if (global.answering &amp;&amp; !global.changing &amp;&amp; array_contains(global.cardTypes[card_change], cardStack)) {
        var tempSize = ds_list_size(global.cardList);
        ds_list_clear(global.cardList);
        
        if (tempSize &gt; 0) {
            with (obj_cards) {
                if (status == stack_normal) {
                    scr_playAnimation(animation_change, x, y, image_index);
                    instance_destroy();
                }
                
                if (status == stack_grab) {
                    targets[global.playerID] = true;
                    newCards[global.playerID] = tempSize;
                }
            }
            
            global.cardView = 0;
            global.changing = true;
            penaltyCards = true;
        }
    }
    
    if (global.answering &amp;&amp; instance_number(obj_cards) - 2 == 1 &amp;&amp; !global.UNO) {
        with (obj_cards) {
            if (status == stack_grab) {
                targets[global.playerID] = true;
                newCards[global.playerID] = 2;
            }
        }
        
        penaltyCards = true;
    }
    
    if (!global.gameInitial &amp;&amp; !global.sendAll &amp;&amp; !global.drew) {
        var turn = 1;
    
        if (global.answering || choseColor) {
            if (array_contains(global.cardTypes[card_skip], cardStack)) {
                turn = 2;
            } else if (array_contains(global.cardTypes[card_reverse], cardStack)) {
                global.leftTurns = !global.leftTurns;
            
                if (global.numberPlayers == 2)
                    turn = 0;
            } else if (array_contains(global.cardTypes[card_add2], cardStack)) {
                sendCards = global.sentNewCards + 2;
            } else if (array_contains(global.cardTypes[card_add2all], cardStack)) {
                sendCards = 2;
                sendAll = (global.numberPlayers &gt; 2);
            } else if (array_contains(global.cardTypes[card_boomerang], cardStack)) {
                sendCards = global.sentNewCards;
                usedBoomerang = true;
            } else if (array_contains(global.cardTypes[card_add4], cardStack)) {
                sendCards = 4;
            }
        }
        
        scr_incrementTurn(turn); 
    }

    buffer_seek(global.buffer, buffer_seek_start, 0);
    buffer_write(global.buffer, buffer_u8, packets.playerTurnInfo);
    buffer_write(global.buffer, buffer_u8, global.playerID);
    buffer_write(global.buffer, buffer_bool, global.gameStarted);
    buffer_write(global.buffer, buffer_bool, global.answering);
    buffer_write(global.buffer, buffer_u8, cardStack);
    buffer_write(global.buffer, buffer_u8, global.cardColor);
    buffer_write(global.buffer, buffer_u8, global.playerTurn);
    buffer_write(global.buffer, buffer_bool, global.leftTurns);
    buffer_write(global.buffer, buffer_u16, sendCards);
    buffer_write(global.buffer, buffer_bool, sendAll);
    buffer_write(global.buffer, buffer_bool, usedBoomerang);
    buffer_write(global.buffer, buffer_u8, global.playerAttacking);
    buffer_write(global.buffer, buffer_u8, global.currentTeam);
    network_send_packet(global.socket, global.buffer, buffer_tell(global.buffer));
}

with (obj_gameController) {
    event_perform(ev_step, ev_step_normal);
    event_user(0);
}

if (global.gameInitial &amp;&amp; !penaltyCards &amp;&amp; !global.drew &amp;&amp; (global.limitedAnswer || global.limitedPlay) &amp;&amp; global.playerTurn == global.playerID) {
    with (obj_gameController) {
        event_user(1);
    }
}

if (global.playerTurn != global.playerID)
    obj_gameController.alarm[0] = 0;

global.gameInitial = false;
global.gameStarted = true;
global.sentNewCards = 0;
global.sendAll = false;
global.usedBoomerang = false;
global.playerAttacking = -1;
global.answering = false;
global.drawing = false;

if (!penaltyCards) global.changing = false;

global.UNO = false;
global.skipping = false;
endAnimation = false;
choseColor = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (status == stack_grab) {
    playerList = array_repeat(noone, global.maxPlayers);
    execute = array_repeat(false, global.maxPlayers);
    targets = array_repeat(false, global.maxPlayers);
    newCards = array_repeat(1, global.maxPlayers);
    cardCount = array_repeat(0, global.maxPlayers);
    grabCards = array_repeat(false, global.maxPlayers);
    cardTimer = array_repeat(0, global.maxPlayers);
    backAngle = array_repeat(0, 4);
    
    for (var i = 0; i &lt; 4; i++)
        backAngle[i] = irandom_range(-10, 10);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

if (status == stack_grab) {
    for (var i = 0; i &lt; 4; i++) {
        draw_sprite_ext(sprite_index, 0, x, y, 1, 1, backAngle[i], c_white, 1);
    }
}

if (global.gameFinished || status != stack_normal || !place_meeting(x, y, obj_cursor)) exit;

draw_sprite(spr_cardsOutline, floor(outlineIndex), x, y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
